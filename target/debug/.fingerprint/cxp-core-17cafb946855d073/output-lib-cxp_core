{"$message_type":"diagnostic","message":"unused imports: `BinaryEmbedding`, `Int8Embedding`, and `QuantizedEmbeddings`","code":{"code":"unused_imports","explanation":null},"level":"warning","spans":[{"file_name":"cxp-core/src/format.rs","byte_start":1139,"byte_end":1154,"line_start":29,"line_end":29,"column_start":13,"column_end":28,"is_primary":true,"text":[{"text":"use crate::{BinaryEmbedding, Int8Embedding, QuantizedEmbeddings};","highlight_start":13,"highlight_end":28}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null},{"file_name":"cxp-core/src/format.rs","byte_start":1156,"byte_end":1169,"line_start":29,"line_end":29,"column_start":30,"column_end":43,"is_primary":true,"text":[{"text":"use crate::{BinaryEmbedding, Int8Embedding, QuantizedEmbeddings};","highlight_start":30,"highlight_end":43}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null},{"file_name":"cxp-core/src/format.rs","byte_start":1171,"byte_end":1190,"line_start":29,"line_end":29,"column_start":45,"column_end":64,"is_primary":true,"text":[{"text":"use crate::{BinaryEmbedding, Int8Embedding, QuantizedEmbeddings};","highlight_start":45,"highlight_end":64}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"`#[warn(unused_imports)]` (part of `#[warn(unused)]`) on by default","code":null,"level":"note","spans":[],"children":[],"rendered":null},{"message":"remove the whole `use` item","code":null,"level":"help","spans":[{"file_name":"cxp-core/src/format.rs","byte_start":1062,"byte_end":1193,"line_start":28,"line_end":30,"column_start":1,"column_end":1,"is_primary":true,"text":[{"text":"#[cfg(any(feature = \"embeddings\", feature = \"embeddings-wasm\"))]","highlight_start":1,"highlight_end":65},{"text":"use crate::{BinaryEmbedding, Int8Embedding, QuantizedEmbeddings};","highlight_start":1,"highlight_end":66},{"text":"","highlight_start":1,"highlight_end":1}],"label":null,"suggested_replacement":"","suggestion_applicability":"MachineApplicable","expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[1m\u001b[33mwarning\u001b[0m\u001b[1m: unused imports: `BinaryEmbedding`, `Int8Embedding`, and `QuantizedEmbeddings`\u001b[0m\n  \u001b[1m\u001b[94m--> \u001b[0mcxp-core/src/format.rs:29:13\n   \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m29\u001b[0m \u001b[1m\u001b[94m|\u001b[0m use crate::{BinaryEmbedding, Int8Embedding, QuantizedEmbeddings};\n   \u001b[1m\u001b[94m|\u001b[0m             \u001b[1m\u001b[33m^^^^^^^^^^^^^^^\u001b[0m  \u001b[1m\u001b[33m^^^^^^^^^^^^^\u001b[0m  \u001b[1m\u001b[33m^^^^^^^^^^^^^^^^^^^\u001b[0m\n   \u001b[1m\u001b[94m|\u001b[0m\n   \u001b[1m\u001b[94m= \u001b[0m\u001b[1mnote\u001b[0m: `#[warn(unused_imports)]` (part of `#[warn(unused)]`) on by default\n\n"}
{"$message_type":"diagnostic","message":"unused imports: `serialize_binary_embeddings` and `serialize_int8_embeddings`","code":{"code":"unused_imports","explanation":null},"level":"warning","spans":[{"file_name":"cxp-core/src/format.rs","byte_start":1464,"byte_end":1491,"line_start":37,"line_end":37,"column_start":13,"column_end":40,"is_primary":true,"text":[{"text":"use crate::{serialize_binary_embeddings, deserialize_binary_embeddings, serialize_int8_embeddings, deserialize_int8_embeddings};","highlight_start":13,"highlight_end":40}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null},{"file_name":"cxp-core/src/format.rs","byte_start":1524,"byte_end":1549,"line_start":37,"line_end":37,"column_start":73,"column_end":98,"is_primary":true,"text":[{"text":"use crate::{serialize_binary_embeddings, deserialize_binary_embeddings, serialize_int8_embeddings, deserialize_int8_embeddings};","highlight_start":73,"highlight_end":98}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"remove the unused imports","code":null,"level":"help","spans":[{"file_name":"cxp-core/src/format.rs","byte_start":1464,"byte_end":1493,"line_start":37,"line_end":37,"column_start":13,"column_end":42,"is_primary":true,"text":[{"text":"use crate::{serialize_binary_embeddings, deserialize_binary_embeddings, serialize_int8_embeddings, deserialize_int8_embeddings};","highlight_start":13,"highlight_end":42}],"label":null,"suggested_replacement":"","suggestion_applicability":"MachineApplicable","expansion":null},{"file_name":"cxp-core/src/format.rs","byte_start":1522,"byte_end":1549,"line_start":37,"line_end":37,"column_start":71,"column_end":98,"is_primary":true,"text":[{"text":"use crate::{serialize_binary_embeddings, deserialize_binary_embeddings, serialize_int8_embeddings, deserialize_int8_embeddings};","highlight_start":71,"highlight_end":98}],"label":null,"suggested_replacement":"","suggestion_applicability":"MachineApplicable","expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[1m\u001b[33mwarning\u001b[0m\u001b[1m: unused imports: `serialize_binary_embeddings` and `serialize_int8_embeddings`\u001b[0m\n  \u001b[1m\u001b[94m--> \u001b[0mcxp-core/src/format.rs:37:13\n   \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m37\u001b[0m \u001b[1m\u001b[94m|\u001b[0m use crate::{serialize_binary_embeddings, deserialize_binary_embeddings, serialize_int8_embeddings, deserialize_int8_embeddings};\n   \u001b[1m\u001b[94m|\u001b[0m             \u001b[1m\u001b[33m^^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m                                 \u001b[1m\u001b[33m^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\n"}
{"$message_type":"diagnostic","message":"the trait bound `SessionInputValue<'_>: From<ArrayBase<ViewRepr<&i64>, Dim<[usize; 2]>>>` is not satisfied","code":{"code":"E0277","explanation":"You tried to use a type which doesn't implement some trait in a place which\nexpected that trait.\n\nErroneous code example:\n\n```compile_fail,E0277\n// here we declare the Foo trait with a bar method\ntrait Foo {\n    fn bar(&self);\n}\n\n// we now declare a function which takes an object implementing the Foo trait\nfn some_func<T: Foo>(foo: T) {\n    foo.bar();\n}\n\nfn main() {\n    // we now call the method with the i32 type, which doesn't implement\n    // the Foo trait\n    some_func(5i32); // error: the trait bound `i32 : Foo` is not satisfied\n}\n```\n\nIn order to fix this error, verify that the type you're using does implement\nthe trait. Example:\n\n```\ntrait Foo {\n    fn bar(&self);\n}\n\n// we implement the trait on the i32 type\nimpl Foo for i32 {\n    fn bar(&self) {}\n}\n\nfn some_func<T: Foo>(foo: T) {\n    foo.bar(); // we can now use this method since i32 implements the\n               // Foo trait\n}\n\nfn main() {\n    some_func(5i32); // ok!\n}\n```\n\nOr in a generic context, an erroneous code example would look like:\n\n```compile_fail,E0277\nfn some_func<T>(foo: T) {\n    println!(\"{:?}\", foo); // error: the trait `core::fmt::Debug` is not\n                           //        implemented for the type `T`\n}\n\nfn main() {\n    // We now call the method with the i32 type,\n    // which *does* implement the Debug trait.\n    some_func(5i32);\n}\n```\n\nNote that the error here is in the definition of the generic function. Although\nwe only call it with a parameter that does implement `Debug`, the compiler\nstill rejects the function. It must work with all possible input types. In\norder to make this example compile, we need to restrict the generic type we're\naccepting:\n\n```\nuse std::fmt;\n\n// Restrict the input type to types that implement Debug.\nfn some_func<T: fmt::Debug>(foo: T) {\n    println!(\"{:?}\", foo);\n}\n\nfn main() {\n    // Calling the method is still fine, as i32 implements Debug.\n    some_func(5i32);\n\n    // This would fail to compile now:\n    // struct WithoutDebug;\n    // some_func(WithoutDebug);\n}\n```\n\nRust only looks at the signature of the called function, as such it must\nalready specify all requirements that will be used for every type parameter.\n"},"level":"error","spans":[{"file_name":"/Users/einarjaeger/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/ort-2.0.0-rc.10/src/session/input.rs","byte_start":3776,"byte_end":3816,"line_start":117,"line_end":117,"column_start":67,"column_end":107,"is_primary":true,"text":[{"text":"\t\tvec![$(($crate::__private::alloc::borrow::Cow::<str>::from($n), $crate::session::SessionInputValue::<'_>::from($v)),)+]","highlight_start":67,"highlight_end":107}],"label":"the trait `From<ArrayBase<ViewRepr<&i64>, Dim<[usize; 2]>>>` is not implemented for `SessionInputValue<'_>`","suggested_replacement":null,"suggestion_applicability":null,"expansion":{"span":{"file_name":"cxp-core/src/embeddings.rs","byte_start":6303,"byte_end":6427,"line_start":208,"line_end":211,"column_start":40,"column_end":10,"is_primary":false,"text":[{"text":"        let outputs = self.session.run(ort::inputs! {","highlight_start":40,"highlight_end":54},{"text":"            \"input_ids\" => input_ids.view(),","highlight_start":1,"highlight_end":45},{"text":"            \"attention_mask\" => attention_mask.view(),","highlight_start":1,"highlight_end":55},{"text":"        }?)?;","highlight_start":1,"highlight_end":10}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null},"macro_decl_name":"ort::inputs!","def_site_span":{"file_name":"/Users/einarjaeger/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/ort-2.0.0-rc.10/src/session/input.rs","byte_start":3519,"byte_end":3538,"line_start":112,"line_end":112,"column_start":1,"column_end":20,"is_primary":false,"text":[{"text":"macro_rules! inputs {","highlight_start":1,"highlight_end":20}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}}}],"children":[{"message":"the following other types implement trait `From<T>`:\n  `SessionInputValue<'_>` implements `From<&ort::value::Value<T>>`\n  `SessionInputValue<'_>` implements `From<ValueRef<'_, T>>`\n  `SessionInputValue<'_>` implements `From<ValueRefMut<'_, T>>`\n  `SessionInputValue<'_>` implements `From<ort::value::Value<T>>`","code":null,"level":"help","spans":[],"children":[],"rendered":null}],"rendered":"\u001b[1m\u001b[91merror[E0277]\u001b[0m\u001b[1m: the trait bound `SessionInputValue<'_>: From<ArrayBase<ViewRepr<&i64>, Dim<[usize; 2]>>>` is not satisfied\u001b[0m\n   \u001b[1m\u001b[94m--> \u001b[0mcxp-core/src/embeddings.rs:208:40\n    \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m208\u001b[0m \u001b[1m\u001b[94m|\u001b[0m           let outputs = self.session.run(ort::inputs! {\n    \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[91m ________________________________________^\u001b[0m\n\u001b[1m\u001b[94m209\u001b[0m \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[91m|\u001b[0m             \"input_ids\" => input_ids.view(),\n\u001b[1m\u001b[94m210\u001b[0m \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[91m|\u001b[0m             \"attention_mask\" => attention_mask.view(),\n\u001b[1m\u001b[94m211\u001b[0m \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[91m|\u001b[0m         }?)?;\n    \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[91m|_________^\u001b[0m \u001b[1m\u001b[91mthe trait `From<ArrayBase<ViewRepr<&i64>, Dim<[usize; 2]>>>` is not implemented for `SessionInputValue<'_>`\u001b[0m\n    \u001b[1m\u001b[94m|\u001b[0m\n    \u001b[1m\u001b[94m= \u001b[0m\u001b[1mhelp\u001b[0m: the following other types implement trait `From<T>`:\n              `SessionInputValue<'_>` implements `From<&ort::value::Value<T>>`\n              `SessionInputValue<'_>` implements `From<ValueRef<'_, T>>`\n              `SessionInputValue<'_>` implements `From<ValueRefMut<'_, T>>`\n              `SessionInputValue<'_>` implements `From<ort::value::Value<T>>`\n    \u001b[1m\u001b[94m= \u001b[0m\u001b[1mnote\u001b[0m: this error originates in the macro `ort::inputs` (in Nightly builds, run with -Z macro-backtrace for more info)\n\n"}
{"$message_type":"diagnostic","message":"the `?` operator can only be applied to values that implement `Try`","code":{"code":"E0277","explanation":"You tried to use a type which doesn't implement some trait in a place which\nexpected that trait.\n\nErroneous code example:\n\n```compile_fail,E0277\n// here we declare the Foo trait with a bar method\ntrait Foo {\n    fn bar(&self);\n}\n\n// we now declare a function which takes an object implementing the Foo trait\nfn some_func<T: Foo>(foo: T) {\n    foo.bar();\n}\n\nfn main() {\n    // we now call the method with the i32 type, which doesn't implement\n    // the Foo trait\n    some_func(5i32); // error: the trait bound `i32 : Foo` is not satisfied\n}\n```\n\nIn order to fix this error, verify that the type you're using does implement\nthe trait. Example:\n\n```\ntrait Foo {\n    fn bar(&self);\n}\n\n// we implement the trait on the i32 type\nimpl Foo for i32 {\n    fn bar(&self) {}\n}\n\nfn some_func<T: Foo>(foo: T) {\n    foo.bar(); // we can now use this method since i32 implements the\n               // Foo trait\n}\n\nfn main() {\n    some_func(5i32); // ok!\n}\n```\n\nOr in a generic context, an erroneous code example would look like:\n\n```compile_fail,E0277\nfn some_func<T>(foo: T) {\n    println!(\"{:?}\", foo); // error: the trait `core::fmt::Debug` is not\n                           //        implemented for the type `T`\n}\n\nfn main() {\n    // We now call the method with the i32 type,\n    // which *does* implement the Debug trait.\n    some_func(5i32);\n}\n```\n\nNote that the error here is in the definition of the generic function. Although\nwe only call it with a parameter that does implement `Debug`, the compiler\nstill rejects the function. It must work with all possible input types. In\norder to make this example compile, we need to restrict the generic type we're\naccepting:\n\n```\nuse std::fmt;\n\n// Restrict the input type to types that implement Debug.\nfn some_func<T: fmt::Debug>(foo: T) {\n    println!(\"{:?}\", foo);\n}\n\nfn main() {\n    // Calling the method is still fine, as i32 implements Debug.\n    some_func(5i32);\n\n    // This would fail to compile now:\n    // struct WithoutDebug;\n    // some_func(WithoutDebug);\n}\n```\n\nRust only looks at the signature of the called function, as such it must\nalready specify all requirements that will be used for every type parameter.\n"},"level":"error","spans":[{"file_name":"cxp-core/src/embeddings.rs","byte_start":6303,"byte_end":6428,"line_start":208,"line_end":211,"column_start":40,"column_end":11,"is_primary":true,"text":[{"text":"        let outputs = self.session.run(ort::inputs! {","highlight_start":40,"highlight_end":54},{"text":"            \"input_ids\" => input_ids.view(),","highlight_start":1,"highlight_end":45},{"text":"            \"attention_mask\" => attention_mask.view(),","highlight_start":1,"highlight_end":55},{"text":"        }?)?;","highlight_start":1,"highlight_end":11}],"label":"the `?` operator cannot be applied to type `Vec<(Cow<'_, str>, SessionInputValue<'_>)>`","suggested_replacement":null,"suggestion_applicability":null,"expansion":{"span":{"file_name":"cxp-core/src/embeddings.rs","byte_start":6303,"byte_end":6428,"line_start":208,"line_end":211,"column_start":40,"column_end":11,"is_primary":false,"text":[{"text":"        let outputs = self.session.run(ort::inputs! {","highlight_start":40,"highlight_end":54},{"text":"            \"input_ids\" => input_ids.view(),","highlight_start":1,"highlight_end":45},{"text":"            \"attention_mask\" => attention_mask.view(),","highlight_start":1,"highlight_end":55},{"text":"        }?)?;","highlight_start":1,"highlight_end":11}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null},"macro_decl_name":"desugaring of operator `?`","def_site_span":{"file_name":"cxp-core/src/lib.rs","byte_start":0,"byte_end":0,"line_start":1,"line_end":1,"column_start":1,"column_end":1,"is_primary":false,"text":[],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}}}],"children":[{"message":"the trait `Try` is not implemented for `Vec<(Cow<'_, str>, SessionInputValue<'_>)>`","code":null,"level":"help","spans":[],"children":[],"rendered":null}],"rendered":"\u001b[1m\u001b[91merror[E0277]\u001b[0m\u001b[1m: the `?` operator can only be applied to values that implement `Try`\u001b[0m\n   \u001b[1m\u001b[94m--> \u001b[0mcxp-core/src/embeddings.rs:208:40\n    \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m208\u001b[0m \u001b[1m\u001b[94m|\u001b[0m           let outputs = self.session.run(ort::inputs! {\n    \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[91m ________________________________________^\u001b[0m\n\u001b[1m\u001b[94m209\u001b[0m \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[91m|\u001b[0m             \"input_ids\" => input_ids.view(),\n\u001b[1m\u001b[94m210\u001b[0m \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[91m|\u001b[0m             \"attention_mask\" => attention_mask.view(),\n\u001b[1m\u001b[94m211\u001b[0m \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[91m|\u001b[0m         }?)?;\n    \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[91m|__________^\u001b[0m \u001b[1m\u001b[91mthe `?` operator cannot be applied to type `Vec<(Cow<'_, str>, SessionInputValue<'_>)>`\u001b[0m\n    \u001b[1m\u001b[94m|\u001b[0m\n    \u001b[1m\u001b[94m= \u001b[0m\u001b[1mhelp\u001b[0m: the trait `Try` is not implemented for `Vec<(Cow<'_, str>, SessionInputValue<'_>)>`\n\n"}
{"$message_type":"diagnostic","message":"no method named `extract_tensor` found for reference `&ort::value::Value` in the current scope","code":{"code":"E0599","explanation":"This error occurs when a method is used on a type which doesn't implement it:\n\nErroneous code example:\n\n```compile_fail,E0599\nstruct Mouth;\n\nlet x = Mouth;\nx.chocolate(); // error: no method named `chocolate` found for type `Mouth`\n               //        in the current scope\n```\n\nIn this case, you need to implement the `chocolate` method to fix the error:\n\n```\nstruct Mouth;\n\nimpl Mouth {\n    fn chocolate(&self) { // We implement the `chocolate` method here.\n        println!(\"Hmmm! I love chocolate!\");\n    }\n}\n\nlet x = Mouth;\nx.chocolate(); // ok!\n```\n"},"level":"error","spans":[{"file_name":"cxp-core/src/embeddings.rs","byte_start":6754,"byte_end":6768,"line_start":218,"line_end":218,"column_start":46,"column_end":60,"is_primary":true,"text":[{"text":"        let embeddings: Array2<f32> = output.extract_tensor::<f32>()?.to_owned();","highlight_start":46,"highlight_end":60}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"there is a method `try_extract_tensor` with a similar name","code":null,"level":"help","spans":[{"file_name":"cxp-core/src/embeddings.rs","byte_start":6754,"byte_end":6768,"line_start":218,"line_end":218,"column_start":46,"column_end":60,"is_primary":true,"text":[{"text":"        let embeddings: Array2<f32> = output.extract_tensor::<f32>()?.to_owned();","highlight_start":46,"highlight_end":60}],"label":null,"suggested_replacement":"try_extract_tensor","suggestion_applicability":"MaybeIncorrect","expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[1m\u001b[91merror[E0599]\u001b[0m\u001b[1m: no method named `extract_tensor` found for reference `&ort::value::Value` in the current scope\u001b[0m\n   \u001b[1m\u001b[94m--> \u001b[0mcxp-core/src/embeddings.rs:218:46\n    \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m218\u001b[0m \u001b[1m\u001b[94m|\u001b[0m         let embeddings: Array2<f32> = output.extract_tensor::<f32>()?.to_owned();\n    \u001b[1m\u001b[94m|\u001b[0m                                              \u001b[1m\u001b[91m^^^^^^^^^^^^^^\u001b[0m\n    \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[96mhelp\u001b[0m: there is a method `try_extract_tensor` with a similar name\n    \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m218\u001b[0m \u001b[1m\u001b[94m| \u001b[0m        let embeddings: Array2<f32> = output.\u001b[92mtry_\u001b[0mextract_tensor::<f32>()?.to_owned();\n    \u001b[1m\u001b[94m|\u001b[0m                                              \u001b[92m++++\u001b[0m\n\n"}
{"$message_type":"diagnostic","message":"type annotations needed","code":{"code":"E0282","explanation":"The compiler could not infer a type and asked for a type annotation.\n\nErroneous code example:\n\n```compile_fail,E0282\nlet x = Vec::new();\n```\n\nThis error indicates that type inference did not result in one unique possible\ntype, and extra information is required. In most cases this can be provided\nby adding a type annotation. Sometimes you need to specify a generic type\nparameter manually.\n\nIn the example above, type `Vec` has a type parameter `T`. When calling\n`Vec::new`, barring any other later usage of the variable `x` that allows the\ncompiler to infer what type `T` is, the compiler needs to be told what it is.\n\nThe type can be specified on the variable:\n\n```\nlet x: Vec<i32> = Vec::new();\n```\n\nThe type can also be specified in the path of the expression:\n\n```\nlet x = Vec::<i32>::new();\n```\n\nIn cases with more complex types, it is not necessary to annotate the full\ntype. Once the ambiguity is resolved, the compiler can infer the rest:\n\n```\nlet x: Vec<_> = \"hello\".chars().rev().collect();\n```\n\nAnother way to provide the compiler with enough information, is to specify the\ngeneric type parameter:\n\n```\nlet x = \"hello\".chars().rev().collect::<Vec<char>>();\n```\n\nAgain, you need not specify the full type if the compiler can infer it:\n\n```\nlet x = \"hello\".chars().rev().collect::<Vec<_>>();\n```\n\nApart from a method or function with a generic type parameter, this error can\noccur when a type parameter of a struct or trait cannot be inferred. In that\ncase it is not always possible to use a type annotation, because all candidates\nhave the same return type. For instance:\n\n```compile_fail,E0282\nstruct Foo<T> {\n    num: T,\n}\n\nimpl<T> Foo<T> {\n    fn bar() -> i32 {\n        0\n    }\n\n    fn baz() {\n        let number = Foo::bar();\n    }\n}\n```\n\nThis will fail because the compiler does not know which instance of `Foo` to\ncall `bar` on. Change `Foo::bar()` to `Foo::<T>::bar()` to resolve the error.\n"},"level":"error","spans":[{"file_name":"cxp-core/src/embeddings.rs","byte_start":6992,"byte_end":6995,"line_start":223,"line_end":223,"column_start":47,"column_end":50,"is_primary":false,"text":[{"text":"            embeddings.outer_iter().map(|row| row.to_vec()).collect()","highlight_start":47,"highlight_end":50}],"label":"type must be known at this point","suggested_replacement":null,"suggestion_applicability":null,"expansion":null},{"file_name":"cxp-core/src/embeddings.rs","byte_start":6987,"byte_end":6990,"line_start":223,"line_end":223,"column_start":42,"column_end":45,"is_primary":true,"text":[{"text":"            embeddings.outer_iter().map(|row| row.to_vec()).collect()","highlight_start":42,"highlight_end":45}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"consider giving this closure parameter an explicit type","code":null,"level":"help","spans":[{"file_name":"cxp-core/src/embeddings.rs","byte_start":6990,"byte_end":6990,"line_start":223,"line_end":223,"column_start":45,"column_end":45,"is_primary":true,"text":[{"text":"            embeddings.outer_iter().map(|row| row.to_vec()).collect()","highlight_start":45,"highlight_end":45}],"label":null,"suggested_replacement":": /* Type */","suggestion_applicability":"HasPlaceholders","expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[1m\u001b[91merror[E0282]\u001b[0m\u001b[1m: type annotations needed\u001b[0m\n   \u001b[1m\u001b[94m--> \u001b[0mcxp-core/src/embeddings.rs:223:42\n    \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m223\u001b[0m \u001b[1m\u001b[94m|\u001b[0m             embeddings.outer_iter().map(|row| row.to_vec()).collect()\n    \u001b[1m\u001b[94m|\u001b[0m                                          \u001b[1m\u001b[91m^^^\u001b[0m  \u001b[1m\u001b[94m---\u001b[0m \u001b[1m\u001b[94mtype must be known at this point\u001b[0m\n    \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[96mhelp\u001b[0m: consider giving this closure parameter an explicit type\n    \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m223\u001b[0m \u001b[1m\u001b[94m| \u001b[0m            embeddings.outer_iter().map(|row\u001b[92m: /* Type */\u001b[0m| row.to_vec()).collect()\n    \u001b[1m\u001b[94m|\u001b[0m                                             \u001b[92m++++++++++++\u001b[0m\n\n"}
{"$message_type":"diagnostic","message":"type annotations needed","code":{"code":"E0282","explanation":"The compiler could not infer a type and asked for a type annotation.\n\nErroneous code example:\n\n```compile_fail,E0282\nlet x = Vec::new();\n```\n\nThis error indicates that type inference did not result in one unique possible\ntype, and extra information is required. In most cases this can be provided\nby adding a type annotation. Sometimes you need to specify a generic type\nparameter manually.\n\nIn the example above, type `Vec` has a type parameter `T`. When calling\n`Vec::new`, barring any other later usage of the variable `x` that allows the\ncompiler to infer what type `T` is, the compiler needs to be told what it is.\n\nThe type can be specified on the variable:\n\n```\nlet x: Vec<i32> = Vec::new();\n```\n\nThe type can also be specified in the path of the expression:\n\n```\nlet x = Vec::<i32>::new();\n```\n\nIn cases with more complex types, it is not necessary to annotate the full\ntype. Once the ambiguity is resolved, the compiler can infer the rest:\n\n```\nlet x: Vec<_> = \"hello\".chars().rev().collect();\n```\n\nAnother way to provide the compiler with enough information, is to specify the\ngeneric type parameter:\n\n```\nlet x = \"hello\".chars().rev().collect::<Vec<char>>();\n```\n\nAgain, you need not specify the full type if the compiler can infer it:\n\n```\nlet x = \"hello\".chars().rev().collect::<Vec<_>>();\n```\n\nApart from a method or function with a generic type parameter, this error can\noccur when a type parameter of a struct or trait cannot be inferred. In that\ncase it is not always possible to use a type annotation, because all candidates\nhave the same return type. For instance:\n\n```compile_fail,E0282\nstruct Foo<T> {\n    num: T,\n}\n\nimpl<T> Foo<T> {\n    fn bar() -> i32 {\n        0\n    }\n\n    fn baz() {\n        let number = Foo::bar();\n    }\n}\n```\n\nThis will fail because the compiler does not know which instance of `Foo` to\ncall `bar` on. Change `Foo::bar()` to `Foo::<T>::bar()` to resolve the error.\n"},"level":"error","spans":[{"file_name":"cxp-core/src/embeddings.rs","byte_start":7274,"byte_end":7277,"line_start":230,"line_end":230,"column_start":28,"column_end":31,"is_primary":false,"text":[{"text":"                .map(|row| row.to_vec())","highlight_start":28,"highlight_end":31}],"label":"type must be known at this point","suggested_replacement":null,"suggestion_applicability":null,"expansion":null},{"file_name":"cxp-core/src/embeddings.rs","byte_start":7269,"byte_end":7272,"line_start":230,"line_end":230,"column_start":23,"column_end":26,"is_primary":true,"text":[{"text":"                .map(|row| row.to_vec())","highlight_start":23,"highlight_end":26}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"consider giving this closure parameter an explicit type","code":null,"level":"help","spans":[{"file_name":"cxp-core/src/embeddings.rs","byte_start":7272,"byte_end":7272,"line_start":230,"line_end":230,"column_start":26,"column_end":26,"is_primary":true,"text":[{"text":"                .map(|row| row.to_vec())","highlight_start":26,"highlight_end":26}],"label":null,"suggested_replacement":": /* Type */","suggestion_applicability":"HasPlaceholders","expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[1m\u001b[91merror[E0282]\u001b[0m\u001b[1m: type annotations needed\u001b[0m\n   \u001b[1m\u001b[94m--> \u001b[0mcxp-core/src/embeddings.rs:230:23\n    \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m230\u001b[0m \u001b[1m\u001b[94m|\u001b[0m                 .map(|row| row.to_vec())\n    \u001b[1m\u001b[94m|\u001b[0m                       \u001b[1m\u001b[91m^^^\u001b[0m  \u001b[1m\u001b[94m---\u001b[0m \u001b[1m\u001b[94mtype must be known at this point\u001b[0m\n    \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[96mhelp\u001b[0m: consider giving this closure parameter an explicit type\n    \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m230\u001b[0m \u001b[1m\u001b[94m| \u001b[0m                .map(|row\u001b[92m: /* Type */\u001b[0m| row.to_vec())\n    \u001b[1m\u001b[94m|\u001b[0m                          \u001b[92m++++++++++++\u001b[0m\n\n"}
{"$message_type":"diagnostic","message":"aborting due to 5 previous errors; 2 warnings emitted","code":null,"level":"error","spans":[],"children":[],"rendered":"\u001b[1m\u001b[91merror\u001b[0m\u001b[1m: aborting due to 5 previous errors; 2 warnings emitted\u001b[0m\n\n"}
{"$message_type":"diagnostic","message":"Some errors have detailed explanations: E0277, E0282, E0599.","code":null,"level":"failure-note","spans":[],"children":[],"rendered":"\u001b[1mSome errors have detailed explanations: E0277, E0282, E0599.\u001b[0m\n"}
{"$message_type":"diagnostic","message":"For more information about an error, try `rustc --explain E0277`.","code":null,"level":"failure-note","spans":[],"children":[],"rendered":"\u001b[1mFor more information about an error, try `rustc --explain E0277`.\u001b[0m\n"}
